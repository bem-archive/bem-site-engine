block('block-jsdoc')(
    content()(function () {
        // if we get html display it
        if (typeof this.data.node.source.jsdoc === 'string') return this.data.node.source.jsdoc;

        // TODO: завести баг про генерацию jsdoc для блоков, где нет js
        if (!this.data.node.source.jsdoc.modules) return;

        // TODO: генерировать для всех modules, когда будет исправлен баг в jsd
        var data = this.data.node.source.jsdoc.modules[0],
            proto = data.exports.proto,
            static = data.exports.static;

        if (!proto) return; // TODO: посмотреть случаи, когда нет proto

        return [
            { elem: 'block-name', content: data },
            { elem: 'toc', content: data },
            { elem: 'methods', content: proto.props },
            static ? { elem: 'methods', content: static.props, name: 'static' } : ''
        ];
    }),

    elem('block-name').content()(function () {
        var data = applyNext();
        return (data.exports.bem ? 'Блок ' : 'Модуль ') + data.name;
    }),

    elem('toc').content()(function () {
        var data = applyNext().exports,
            list = [];

        // list.push({ tag: 'h2', content: 'Table of Contents' });

        var getList = function (prop) {
            if (prop.val.accessLevel === 'private') return;
            list.push({
                elem: 'method-link',
                content: prop.key
            });
        };

        // make list for Instance methods
        list.push({ elem: 'toc-title', content: 'Instance methods:' });
        data.proto.props.map(getList);

        // make list for Static methods
        data.static && list.push({ elem: 'toc-title', content: 'Static methods:' }) && data.static.props.map(getList);

        return list;
    }),

    elem('methods').content()(function () {
        return [
            {
                elem: 'methods-type',
                content: (this.ctx.name === 'static' ? 'Static' : 'Instance') + ' methods'
            },
            applyNext().map(function (method) {
                return method.val.accessLevel === 'private' ? '' : {
                    elem: 'method',
                    content: method
                };
            })
        ];
    }),

    elem('method').content()(function () {
        var method = applyNext(),
            val = method.val;

        return [
            { elem: 'method-title', content: method },
            val.deprecated ? { elem: 'desc-deprecated', content: val.deprecated.description } : '',
            val.description ? { elem: 'desc', content: val.description } : '',
            val.params ? { elem: 'args', content: val.params } : ''
        ];
    }),

    elem('method-title').content()(function () {
        var method = applyNext(),
            key = method.key,
            val = method.val;

        return [
            { elem: 'anchor', attrs: { name: key } }, // TODO: problem: we have indentical method's names on levels
            { elem: 'method-name', content: key },
            { elem: 'args-list', content: val.params },
            { elem: 'method-returns', content: val.returns },
            { elem: 'method-labels', content: val }
        ];
    }),

    elem('method-labels')(
        tag()('span'),

        content()(function () {
            var val = applyNext(),
                labels = [];

            (val.accessLevel === 'protected') && labels.push({ elem: 'method-label', content: 'protected' });
            (val.isAbstract) && labels.push({ elem: 'method-label', content: 'abstract' });
            // TODO link to source code
            (val.isOverridden) && labels.push({ elem: 'method-label', content: 'override' });

            return labels;
        })
    ),

    elem('args-list').content()(function () {
        var params = applyNext(),
            argsList = [];

        params && params.map(function (param) {
            argsList.push({
                elem: 'arg',
                elemMods: { optional: param.isOptional },
                content: param.name
            }, ',');
        });

        argsList.pop(); // delete last comma

        return argsList;
    }),

    elem('method-returns').content()(function () {
        var returns = applyNext();
        if (!returns) return;
        var jsType = returns.jsType;
        jsType = jsType.jsType || jsType;

        return ':' + (jsType === '*' ? 'Any' : jsType);
    }),

    elem('desc').content()(function () {
        return [
            {
                elem: 'desc-title',
                content: 'description'
            },
            {
                elem: 'desc-content',
                content: applyNext()
            }
        ];
    }),

    elem('desc-deprecated').content()(function () {
        return [
            {
                elem: 'desc-title',
                content: 'deprecated'
            },
            {
                elem: 'desc-content',
                content: applyNext()
            }
        ];
    }),

    elem('args').content()(function () {
        return [
            {
                elem: 'args-title',
                content: 'arguments'
            },
            {
                elem: 'args-content',
                content: applyNext().map(function (param) {
                    return {
                        elem: 'row',
                        content: param
                    };
                })
            }
        ];
    }),

    elem('row').content()(function () {
        var param = applyNext();
        return [
            {
                elem: 'arg-title',
                content: param.name
            },
            {
                elem: 'arg-description',
                content: [
                    param.jsType ? {
                        elem: 'arg-type',
                        content: param.jsType
                    } : '',
                    '<br>',
                    {
                        elem: 'arg-desc-item',
                        content: param.description
                    }
                ]
            }
        ];
    }),

    elem('arg-type').content()(function () {
        var jsType = applyNext();

        if (!jsType) return;
        return jsType.jsType ? jsType.jsType : Array.isArray(jsType) ? jsType.join(', ') : jsType;
    })
);
